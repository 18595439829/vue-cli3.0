{"version":3,"sources":["webpack:///./node_modules/ol/geom/MultiLineString.js","webpack:///./node_modules/ol/geom/LineString.js","webpack:///./node_modules/ol/geom/flat/center.js","webpack:///./node_modules/ol/geom/MultiPolygon.js","webpack:///./node_modules/ol/geom/MultiPoint.js","webpack:///./node_modules/ol/geom/flat/interpolate.js"],"names":["_array_js__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","_extent_js__WEBPACK_IMPORTED_MODULE_1__","_GeometryLayout_js__WEBPACK_IMPORTED_MODULE_2__","_GeometryType_js__WEBPACK_IMPORTED_MODULE_3__","_LineString_js__WEBPACK_IMPORTED_MODULE_4__","_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_5__","_flat_closest_js__WEBPACK_IMPORTED_MODULE_6__","_flat_deflate_js__WEBPACK_IMPORTED_MODULE_7__","_flat_inflate_js__WEBPACK_IMPORTED_MODULE_8__","_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_9__","_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_10__","_flat_simplify_js__WEBPACK_IMPORTED_MODULE_11__","MultiLineString","SimpleGeometry","coordinates","opt_layout","opt_ends","call","this","ends_","maxDelta_","maxDeltaRevision_","Array","isArray","setCoordinates","undefined","setFlatCoordinates","layout","getLayout","lineStrings","flatCoordinates","ends","i","ii","length","lineString","Object","getFlatCoordinates","push","__proto__","prototype","create","constructor","appendLineString","slice","changed","clone","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","getRevision","Math","sqrt","stride","getCoordinateAtM","m","opt_extrapolate","opt_interpolate","XYM","XYZM","extrapolate","interpolate","getCoordinates","getEnds","getLineString","index","getLineStrings","offset","end","getFlatMidpoints","midpoints","midpoint","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","simplifiedEnds","XY","getType","MULTI_LINE_STRING","intersectsExtent","extent","setLayout","__webpack_exports__","_SimpleGeometry_js__WEBPACK_IMPORTED_MODULE_4__","_flat_closest_js__WEBPACK_IMPORTED_MODULE_5__","_flat_deflate_js__WEBPACK_IMPORTED_MODULE_6__","_flat_inflate_js__WEBPACK_IMPORTED_MODULE_7__","_flat_interpolate_js__WEBPACK_IMPORTED_MODULE_8__","_flat_intersectsextent_js__WEBPACK_IMPORTED_MODULE_9__","_flat_length_js__WEBPACK_IMPORTED_MODULE_10__","_flat_segments_js__WEBPACK_IMPORTED_MODULE_11__","_flat_simplify_js__WEBPACK_IMPORTED_MODULE_12__","LineString","flatMidpoint_","flatMidpointRevision_","appendCoordinate","coordinate","forEachSegment","callback","getCoordinateAt","fraction","opt_dest","getLength","getFlatMidpoint","LINE_STRING","linearRingss","endss","flatCenters","ol_extent","MultiPolygon_MultiPolygon","MultiPolygon","opt_endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","orientedRevision_","orientedFlatCoordinates_","polygons","polygon","j","jj","array","appendPolygon","len","newEndss","closest","getOrientedFlatCoordinates","containsXY","contains","getArea","flat_area","opt_right","orient","inflate","getEndss","getFlatInteriorPoints","interiorpoint","getInteriorPoints","MultiPoint","GeometryLayout","simplifiedEndss","simplify","getPolygon","prevEnds","Polygon","getPolygons","GeometryType","MULTI_POLYGON","intersectsextent","deflate","lastEnds","geom_SimpleGeometry","_GeometryType_js__WEBPACK_IMPORTED_MODULE_2__","_Point_js__WEBPACK_IMPORTED_MODULE_3__","_flat_deflate_js__WEBPACK_IMPORTED_MODULE_5__","_flat_inflate_js__WEBPACK_IMPORTED_MODULE_6__","_math_js__WEBPACK_IMPORTED_MODULE_7__","appendPoint","point","multiPoint","squaredDistance","getPoint","n","getPoints","points","MULTI_POINT","d","interpolatePoint","lineStringCoordinateAtM","lineStringsCoordinateAtM","_math_js__WEBPACK_IMPORTED_MODULE_1__","pointX","NaN","pointY","x1","y1","cumulativeLengths","x2","y2","target","t","o","lo","hi","mid","m0","m1"],"mappings":"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","file":"js/chunk-79c0bffc.682232ab.js","sourcesContent":["/**\n * @module ol/geom/MultiLineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestArrayPoint, arrayMaxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {interpolatePoint, lineStringsCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiLineString(coordinates, opt_layout, opt_ends) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(/** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n    } else if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.ends_ = opt_ends;\n    } else {\n      var layout = this.getLayout();\n      var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      var flatCoordinates = [];\n      var ends = [];\n      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n        var lineString = lineStrings[i];\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n\n  }\n\n  if ( SimpleGeometry ) MultiLineString.__proto__ = SimpleGeometry;\n  MultiLineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiLineString.prototype.constructor = MultiLineString;\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  MultiLineString.prototype.appendLineString = function appendLineString (lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.clone = function clone () {\n    return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiLineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `opt_interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `opt_interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate, opt_interpolate) {\n    if ((this.layout != GeometryLayout.XYM &&\n         this.layout != GeometryLayout.XYZM) ||\n        this.flatCoordinates.length === 0) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n    return lineStringsCoordinateAtM(this.flatCoordinates, 0,\n      this.ends_, this.stride, m, extrapolate, interpolate);\n  };\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinatesArray(\n      this.flatCoordinates, 0, this.ends_, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  MultiLineString.prototype.getEnds = function getEnds () {\n    return this.ends_;\n  };\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  MultiLineString.prototype.getLineString = function getLineString (index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(this.flatCoordinates.slice(\n      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  MultiLineString.prototype.getLineStrings = function getLineStrings () {\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var layout = this.layout;\n    /** @type {Array<LineString>} */\n    var lineStrings = [];\n    var offset = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  };\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints () {\n    var midpoints = [];\n    var flatCoordinates = this.flatCoordinates;\n    var offset = 0;\n    var ends = this.ends_;\n    var stride = this.stride;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var midpoint = interpolatePoint(\n        flatCoordinates, offset, end, stride, 0.5);\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiLineString.prototype.getType = function getType () {\n    return GeometryType.MULTI_LINE_STRING;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiLineString.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates, 0, this.ends_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = deflateCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return MultiLineString;\n}(SimpleGeometry));\n\n\nexport default MultiLineString;\n\n//# sourceMappingURL=MultiLineString.js.map","/**\n * @module ol/geom/LineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {douglasPeucker} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nvar LineString = /*@__PURE__*/(function (SimpleGeometry) {\n  function LineString(coordinates, opt_layout) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) LineString.__proto__ = SimpleGeometry;\n  LineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  LineString.prototype.constructor = LineString;\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  LineString.prototype.appendCoordinate = function appendCoordinate (coordinate) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = coordinate.slice();\n    } else {\n      extend(this.flatCoordinates, coordinate);\n    }\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @override\n   * @api\n   */\n  LineString.prototype.clone = function clone () {\n    return new LineString(this.flatCoordinates.slice(), this.layout);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(maxSquaredDelta(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  LineString.prototype.forEachSegment = function forEachSegment$1 (callback) {\n    return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n  };\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  LineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate) {\n    if (this.layout != GeometryLayout.XYM &&\n        this.layout != GeometryLayout.XYZM) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    return lineStringCoordinateAtM(this.flatCoordinates, 0,\n      this.flatCoordinates.length, this.stride, m, extrapolate);\n  };\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  LineString.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_dest Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  LineString.prototype.getCoordinateAt = function getCoordinateAt (fraction, opt_dest) {\n    return interpolatePoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      fraction, opt_dest);\n  };\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  LineString.prototype.getLength = function getLength () {\n    return lineStringLength(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  LineString.prototype.getFlatMidpoint = function getFlatMidpoint () {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return this.flatMidpoint_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LineString.prototype.getType = function getType () {\n    return GeometryType.LINE_STRING;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LineString.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLineString(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      extent);\n  };\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  LineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return LineString;\n}(SimpleGeometry));\n\n\nexport default LineString;\n\n//# sourceMappingURL=LineString.js.map","/**\n * @module ol/geom/flat/center\n */\nimport {createEmpty, createOrUpdateFromFlatCoordinates} from '../../extent.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  var flatCenters = [];\n  var extent = createEmpty();\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n  return flatCenters;\n}\n\n//# sourceMappingURL=center.js.map","/**\n * @module ol/geom/MultiPolygon\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta} from './flat/closest.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {linearRingsAreOriented, orientLinearRingsArray} from './flat/orient.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiPolygon(coordinates, opt_layout, opt_endss) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!opt_endss && !Array.isArray(coordinates[0])) {\n      var layout = this.getLayout();\n      var polygons = /** @type {Array<Polygon>} */ (coordinates);\n      var flatCoordinates = [];\n      var endss = [];\n      for (var i = 0, ii = polygons.length; i < ii; ++i) {\n        var polygon = polygons[i];\n        if (i === 0) {\n          layout = polygon.getLayout();\n        }\n        var offset = flatCoordinates.length;\n        var ends = polygon.getEnds();\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n      opt_layout = layout;\n      coordinates = flatCoordinates;\n      opt_endss = endss;\n    }\n    if (opt_layout !== undefined && opt_endss) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.endss_ = opt_endss;\n    } else {\n      this.setCoordinates(/** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates),\n        opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) MultiPolygon.__proto__ = SimpleGeometry;\n  MultiPolygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiPolygon.prototype.constructor = MultiPolygon;\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.appendPolygon = function appendPolygon (polygon) {\n    /** @type {Array<number>} */\n    var ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      var offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.clone = function clone () {\n    var len = this.endss_.length;\n    var newEndss = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    return new MultiPolygon(\n      this.flatCoordinates.slice(), this.layout, newEndss);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.containsXY = function containsXY (x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  };\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  MultiPolygon.prototype.getArea = function getArea () {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  };\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.getCoordinates = function getCoordinates (opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates, 0, this.endss_, this.stride);\n  };\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  MultiPolygon.prototype.getEndss = function getEndss () {\n    return this.endss_;\n  };\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints () {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      var flatCenters = linearRingssCenter(\n        this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n        flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  };\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints () {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n  };\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(\n        flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length =\n            orientLinearRingsArray(\n              this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates, 0, this.endss_, this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n  };\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygon = function getPolygon (index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    var offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      var prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    var ends = this.endss_[index].slice();\n    var end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  };\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygons = function getPolygons () {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var endss = this.endss_;\n    var polygons = [];\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i].slice();\n      var end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPolygon.prototype.getType = function getType () {\n    return GeometryType.MULTI_POLYGON;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPolygon.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      var lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ?\n        0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  };\n\n  return MultiPolygon;\n}(SimpleGeometry));\n\n\nexport default MultiPolygon;\n\n//# sourceMappingURL=MultiPolygon.js.map","/**\n * @module ol/geom/MultiPoint\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY, containsXY} from '../extent.js';\nimport GeometryType from './GeometryType.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nvar MultiPoint = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiPoint(coordinates, opt_layout) {\n    SimpleGeometry.call(this);\n    if (opt_layout && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n    }\n  }\n\n  if ( SimpleGeometry ) MultiPoint.__proto__ = SimpleGeometry;\n  MultiPoint.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiPoint.prototype.constructor = MultiPoint;\n\n  /**\n   * Append the passed point to this multipoint.\n   * @param {Point} point Point.\n   * @api\n   */\n  MultiPoint.prototype.appendPoint = function appendPoint (point) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = point.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, point.getFlatCoordinates());\n    }\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPoint} Clone.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.clone = function clone () {\n    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n    return multiPoint;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPoint.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var squaredDistance = squaredDx(\n        x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (var j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  };\n\n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {Point} Point.\n   * @api\n   */\n  MultiPoint.prototype.getPoint = function getPoint (index) {\n    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;\n    if (index < 0 || n <= index) {\n      return null;\n    }\n    return new Point(this.flatCoordinates.slice(\n      index * this.stride, (index + 1) * this.stride), this.layout);\n  };\n\n  /**\n   * Return the points of this multipoint.\n   * @return {Array<Point>} Points.\n   * @api\n   */\n  MultiPoint.prototype.getPoints = function getPoints () {\n    var flatCoordinates = this.flatCoordinates;\n    var layout = this.layout;\n    var stride = this.stride;\n    /** @type {Array<Point>} */\n    var points = [];\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var point = new Point(flatCoordinates.slice(i, i + stride), layout);\n      points.push(point);\n    }\n    return points;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPoint.prototype.getType = function getType () {\n    return GeometryType.MULTI_POINT;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPoint.prototype.intersectsExtent = function intersectsExtent (extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      if (containsXY(extent, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Set the coordinates of the multipoint.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return MultiPoint;\n}(SimpleGeometry));\n\n\nexport default MultiPoint;\n\n//# sourceMappingURL=MultiPoint.js.map","/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] +\n        fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] +\n        fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n    for (var i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    var target = fraction * length;\n    var index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) /\n          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = lerp(\n        flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = lerp(\n        flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  var coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  var lo = offset / stride;\n  var hi = end / stride;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  var m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (var i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i],\n      flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  var coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n}\n\n//# sourceMappingURL=interpolate.js.map"],"sourceRoot":""}